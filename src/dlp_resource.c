/*
 * Copyright (c) 2020 Hans Jerry Illikainen <hji@dyntopia.com>
 *
 * SPDX-License-Identifier:
 */

#include "dlp_resource.h"

#include <glib/gi18n.h>

#include "dlp_error.h"
#include "dlp_gresource.h"
#include "dlp_mem.h"

static bool dlp_resource_get(GResource **resource,
                             GError **error) DLP_NODISCARD;

/**
 * Check if a path refers to a resource file.
 *
 * This function is used to make a distinction between resource paths and file
 * system paths provided by the user in e.g. configuration files.
 *
 * @param path Path to check.
 * @return True if path refers to a resource and false otherwise.
 */
bool dlp_resource_p(const char *path)
{
    g_return_val_if_fail(path != NULL, false);

    return g_str_has_prefix(path, "resource://");
}

/**
 * Check if a path exists in the resource.
 *
 * @param path  Path to check.  It may have an optional resource:// prefix.
 * @param error Optional error information.
 * @return True on success and false on failure.
 */
bool dlp_resource_exists_p(const char *path, GError **error)
{
    GResource *resource;
    GResourceLookupFlags flags = G_RESOURCE_LOOKUP_FLAGS_NONE;

    g_return_val_if_fail(path != NULL, false);

    if (g_str_has_prefix(path, "resource://")) {
        path += strlen("resource://");
    }

    if (!dlp_resource_get(&resource, error)) {
        return false;
    }

    if (!g_resource_get_info(resource, path, flags, NULL, NULL, error)) {
        return false;
    }

    return true;
}

/**
 * Retrieve the data for a resource file.
 *
 * @param path  Path to retrieve.  It may have an optional resource:// prefix.
 * @param data  NUL-terminated data that must be freed after use.
 * @param size  Size of the data, excluding the terminating NUL.
 * @param error Optional error information.
 * @return True on success and false on failure.
 */
bool dlp_resource_data(const char *path, void **data, gsize *size,
                       GError **error)
{
    GResource *resource;
    GBytes *bytes;
    GResourceLookupFlags flags = G_RESOURCE_LOOKUP_FLAGS_NONE;

    g_return_val_if_fail(path != NULL && data != NULL && size != NULL, false);
    *data = NULL;
    *size = 0;

    if (g_str_has_prefix(path, "resource://")) {
        path += strlen("resource://");
    }

    if (!dlp_resource_get(&resource, error)) {
        return false;
    }

    bytes = g_resource_lookup_data(resource, path, flags, error);
    if (bytes == NULL) {
        return false;
    }

    *data = g_bytes_unref_to_data(bytes, size);
    if (*data == NULL || *size == 0) {
        dlp_mem_free(data);
        *size = 0;
        g_set_error(error, DLP_ERROR, G_RESOURCE_ERROR_INTERNAL, "%s",
                    _("unknown error"));
        return false;
    }

    return true;
}

/**
 * Retrieve a GResource.
 *
 * @param resource  Retrieved resource.
 * @param error     Optional error information.
 * @return True on success and false on failure.
 */
static bool dlp_resource_get(GResource **resource, GError **error)
{
    g_return_val_if_fail(resource != NULL, false);

    /* Generated by glib-compile-resources during the build. */
    *resource = dlp_get_resource();
    if (*resource == NULL) {
        g_set_error(error, DLP_ERROR, G_RESOURCE_ERROR_INTERNAL, "%s",
                    _("unknown error"));
        return false;
    }

    return true;
}
